<?php

namespace ProcessWire;

use VersionControl\DataStore;
use VersionControl\Data\Revisions;
use VersionControl\Data\Data;
use VersionControl\Data\Files;

/**
 * Version Control Cleanup Helper
 *
 * This module provides various cleanup features required by the Version Control module. We don't
 * want to store unnecessary data, so with this module we're making sure that expired rows and
 * orphaned files etc. don't just stick around.
 *
 * @copyright 2019-2021 Teppo Koivula
 * @license https://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License, version 2
 */
class VersionControlCleanup extends WireData implements Module, ConfigurableModule {

    /**
     * Default configuration for this module
     *
     * @var array
     */
    public static $defaultData = [
        'cleanup_methods' => [
            'deleted_pages',
            'deleted_fields',
            'changed_template',
            'removed_fieldgroup_fields',
        ],
    ];

    /**
     * Populate the default config data
     *
     * ProcessWire will automatically overwrite it with anything the user has specifically configured.
     * This is done in construct() rather than init() because ProcessWire populates config data after
     * construct(), but before init().
     */
    public function __construct() {
        foreach (static::$defaultData as $key => $value) {
            $this->$key = $value;
        }
    }

    /**
     * Enable version control for all templates?
     *
     * @var bool
     */
    protected $enable_all_templates = false;

    /**
     * Templates with version control enabled
     *
     * @var array
     */
    protected $enabled_templates = [];

    /**
     * Reference to the data store
     *
     * @var DataStore
     */
    protected $store;

    /**
     * Initialization function
     */
    public function init() {

        // Get a reference to the data store.
        $this->store = $this->modules->get('VersionControl')->getDataStore();

        // Remove expired data rows daily.
        $this->addHook("LazyCron::everyDay", $this, 'cleanup');

        // Get main module config data.
        $main_config = array_merge(VersionControl::$defaultData, $this->wire('modules')->getConfig('VersionControl'));
        if ($main_config['enable_all_templates'] || !empty($main_config['enabled_templates'])) {

            // Store necessary settings in local properties
            $this->enable_all_templates = (bool) $main_config['enable_all_templates'];
            $this->enabled_templates = $main_config['enabled_templates'] ?? [];

            // Add hooks that clear obsolete or orphaned data (cleanup).
            $this->addHookAfter('Pages::deleted', $this, 'cleanupDeletedPage');
            $this->addHookBefore('Fields::delete', $this, 'cleanupDeletedField');
            $this->addHook('Pages::templateChanged', $this, 'cleanupChangedTemplate');
            $this->addHookBefore('Fieldgroups::save', $this, 'cleanupRemovedFieldgroupFields');
        }
    }

    /**
     * Module configuration
     *
     * Note: this module isn't meant to be configurable in the usual way. While native features are
     * used to define config inputfields and config settings are stored just like regular module
     * config settings, the user only ever accesses them via the main module, VersionControl.
     *
     * @param array $data
     * @return InputfieldWrapper
     */
    public function getModuleConfigInputfields(array $data) {
        return $this->wire(new \VersionControl\CleanupModuleConfig($data))->getFields();
    }

    /**
     * Delete data older than max age defined in module settings
     */
    protected function cleanup() {

        // check if this cleanup method is disabled
        if (!$this->data_max_age) return;

        // remove data older than specified max age settings
        $this->store->data->purge($this->data_max_age);

        // cleanup files
        $this->cleanupFiles();
    }

    /**
     * Delete files no longer referenced in any data rows
     */
    public function cleanupFiles() {

        // get base path for files
        $files_path = $this->store->files->getPath();
        if (empty($files_path)) {
            // bail out early if files path can't be found
            return;
        }

        // first clean up data files junction table
        $this->database->query("
        DELETE FROM " . Files::TABLE_DATA_FILES . "
        WHERE data_id NOT IN (
            SELECT DISTINCT id FROM " . Data::TABLE . "
        )
        ");

        // find files without connections to stored data rows
        $stmt = $this->database->prepare("
        SELECT *
        FROM " . Files::TABLE . "
        WHERE id NOT IN (
            SELECT DISTINCT files_id from " . Files::TABLE_DATA_FILES . "
        )
        ");
        $stmt->execute();
        $stmt_del = null;
        while ($row = $stmt->fetch(\PDO::FETCH_ASSOC)) {
            // remove file
            $dir = $files_path . substr($row['filename'], 0, 2) . "/";
            $file = $dir . $row['filename'];
            if (is_file($file)) unlink($file);
            // remove file variations (thumbs)
            $path_parts = pathinfo($file);
            $variations = scandir($dir . "variations");
            foreach ($variations as $variation) {
                if (strpos($variation, $path_parts['filename']) === 0) {
                    unlink($dir . "variations/" . $variation);
                }
            }
            // if containing directory is now empty, remove that too
            if (count(scandir($dir)) == 1) wireRmdir($dir, true);
            // delete related row from files database table
            if (!$stmt_del) $stmt_del = $this->database->prepare("DELETE FROM " . Files::TABLE . " WHERE id = :id");
            $stmt_del->bindValue(':id', (int) $row['id'], \PDO::PARAM_INT);
            $stmt_del->execute();
        }

    }

    /**
     * Delete data that exceeds row limit defined in module settings
     *
     * Row limit applies to each unique page + field combination.
     *
     * @param int $pages_id
     * @param int $fields_id
     */
    public function cleanupExcessRows($pages_id, $fields_id) {

        if (!$this->data_row_limit) return;

        $ids = [];
        $t1 = Revisions::TABLE;
        $t2 = Data::TABLE;
        $stmt = $this->database->prepare("
        SELECT $t1.id
        FROM $t1, $t2
        WHERE $t1.pages_id = :pages_id
        AND $t2.fields_id = :fields_id
        AND $t2.revisions_id = $t1.id
        ORDER BY timestamp DESC
        LIMIT :offset, 18446744073709551615
        ");
        $stmt->bindValue(':pages_id', (int) $pages_id, \PDO::PARAM_INT);
        $stmt->bindValue(':fields_id', (int) $fields_id, \PDO::PARAM_INT);
        $stmt->bindValue(':offset', (int) $this->data_row_limit, \PDO::PARAM_INT);
        $stmt->execute();
        while ($row = $stmt->fetch(\PDO::FETCH_ASSOC)) {
            $ids[] = $row['id'];
        }
        if (!empty($ids)) {
            $ids_string = implode(',', $ids);
            $this->database->query("DELETE FROM $t1 WHERE id IN ($ids_string)");
            $this->database->query("DELETE FROM $t2 WHERE revisions_id IN ($ids_string)");
            $this->cleanupFiles();
        }
    }

    /**
     * Remove previously stored data for deleted page
     *
     * Note that this is the only cleanup method that can delete revisions in
     * addition to data. This is intentional, since revisions are always tied
     * to pages.
     *
     * @param HookEvent $event
     */
    public function cleanupDeletedPage(HookEvent $event) {

        // bail out early if this method is disabled
        if (!in_array('deleted_pages', $this->cleanup_methods)) return;

        $page = $event->arguments[0];

        // @todo enable after figuring out a way to clean up once the parent page has been removed
        // if deleted data is for a Repeater item and parent still exists, we don't want to delete it yet
        // if ($page instanceof RepeaterPage) {
        //     $for_page = $page->getForPage();
        //     if ($for_page->id) {
        //         return;
        //     }
        // }

        if ($page instanceof Page) {
            $this->store->data->deleteForPage($page);
            $this->cleanupFiles();
        }
    }

    /**
     * Remove previously stored data for deleted field
     *
     * @param HookEvent $event
     */
    public function cleanupDeletedField(HookEvent $event) {

        // bail out early if this method is disabled
        if (!in_array('deleted_fields', $this->cleanup_methods)) return;

        $field = $event->arguments[0];
        if ($field instanceof Field) {
            $this->store->data->deleteForField($field);
            $this->cleanupFiles();
        }
    }

    /**
     * Remove obsolete data after template change
     *
     * @param HookEvent $event
     */
    public function cleanupChangedTemplate(HookEvent $event) {

        // bail out early if this method is disabled
        if (!in_array('changed_template', $this->cleanup_methods)) return;

        $page = $event->arguments[0];
        if ($page instanceof Page) {
            $fields = implode(",", array_keys($page->template->fields->getArray()));
            $stmt = $this->database->prepare("
            DELETE FROM " . Data::TABLE . "
            WHERE revisions_id IN (
                SELECT id FROM " . Revisions::TABLE . "
                WHERE pages_id = :pages_id
            )
            AND fields_id NOT IN ($fields)
            ");
            $stmt->bindValue(':pages_id', (int) $page->id, \PDO::PARAM_INT);
            $stmt->execute();
            $this->cleanupFiles();
        }
    }

    /**
     * Remove previously stored data for fields removed from fieldgroups
     *
     * @param HookEvent $event
     */
    public function cleanupRemovedFieldgroupFields(HookEvent $event) {

        // bail out early if this method is disabled
        if (!in_array('removed_fieldgroup_fields', $this->cleanup_methods)) return;

        // find out if fields are actually going to be removed (permanent/global
        // flags can result in WireExceptions, terminating removal entirely) and
        // which of those (if any) can have rows in version control data table
        $removed_fields = [];
        $removed_fields_by_template = [];
        $item = $event->arguments[0];
        if ($item instanceof Fieldgroup && $item->id && $item->removedFields) {
            $main_config = array_merge(VersionControl::$defaultData, $this->wire('modules')->getConfig('VersionControl'));
            $enabled_templates = $main_config['enable_all_templates'] ? "" : "id=" . implode("|", $main_config['enabled_templates']) . ", ";
            $removed_fields = $item->removedFields->getArray();
            foreach ($this->templates->find("{$enabled_templates}fieldgroups_id={$item->id}") as $template) {
                foreach ($removed_fields as $id => $field) {
                    if (($field->flags & Field::flagGlobal) && !$template->noGlobal) return;
                    if ($field->flags & Field::flagPermanent) return;
                    if (!in_array($field->type, $main_config['compatible_fieldtypes'])) unset($removed_fields[$id]);
                    if (!empty($main_config['enabled_fields']) && !in_array($id, $main_config['enabled_fields'])) unset($removed_fields[$id]);
                    if (!isset($removed_fields_by_template[$template->id])) $removed_fields_by_template[$template->id] = [];
                    $removed_fields_by_template[$template->id][] = (int) $field->id;
                }
                if (empty($removed_fields)) {
                    return;
                }
            }
        }

        // if we got this far and removed fields were found, delete data rows
        if (!empty($removed_fields)) {
            foreach ($removed_fields_by_template as $template_id => $field_ids) {
                $this->store->data->deleteForTemplate($template_id, $field_ids);
            }
            $this->cleanupFiles();
        }
    }

}
