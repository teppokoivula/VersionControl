<?php

namespace ProcessWire;

use VersionControl\DataStore;
use VersionControl\i18n;

/**
 * Process Version Control
 *
 * This module acts as an interface for Version Control module by making itself available via an Admin page and
 * generating markup based on GET params. For more details see the README.md file distributed with this module.
 *
 * @copyright 2013-2021 Teppo Koivula
 * @license https://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License, version 2
 */
class ProcessVersionControl extends Process implements Module, ConfigurableModule {
    
    /**
     * Default configuration for this module
     *
     * @var array
     */
    public static $defaultData = [
        'date_format' => 'Y-m-d H:i:s',
        'user_name_format' => '{name}',
        'diff_timeout' => 1,
        'diff_efficiency_cleanup_edit_cost' => 4,
    ];

    /**
     * Reference to the data store
     *
     * @var DataStore
     */
    protected $store;

    /**
     * Populate the default config data
     *
     * ProcessWire will automatically overwrite it with anything the user has specifically configured.
     * This is done in construct() rather than init() because ProcessWire populates config data after
     * construct(), but before init().
     */
    public function __construct() {
        foreach (static::$defaultData as $key => $value) {
            $this->$key = $value;
        }
    }

    /**
     * Initialization function
     */
    public function init() {

        // Get a reference to the data store.
        $this->store = $this->modules->get('VersionControl')->getDataStore();

        parent::init();
    }

    /**
     * Module configuration
     *
     * Note: this module isn't meant to be configurable in the usual way. While native features are
     * used to define config inputfields and config settings are stored just like regular module
     * config settings, the user only ever accesses them via the main module, VersionControl.
     *
     * @param array $data
     * @return InputfieldWrapper
     */
    public function getModuleConfigInputfields(array $data): InputfieldWrapper {
        // Note: Version Control is required for class autoloading.
        $this->wire('modules')->get('VersionControl');
        return $this->wire(new \VersionControl\ProcessModuleConfig($data))->getFields();
    }

    /**
     * Placeholder for when a page with this Process assigned is accessed
     * 
     * Currently only displays a 404 error, but could be used for something more useful later.
     * 
     * @throws Wire404Exception when accessed.
     */
    public function execute() {
        throw new Wire404Exception(i18n::getText('Unrecognized path'));
    }

    /**
     * Return revision info for specific page
     *
     * Page is defined by GET param 'pages_id' and additional settings with GET param 'settings'.
     * Supported settings are 'empty' (to render placeholders for fields with no stored data) and
     * 'render' (selecting render method).
     * 
     * @throws WireException if GET param pages_id is missing.
     * @throws WirePermissionException if current user doesn't have edit permission on this page.
     * @return string revision data rendered with one of available render methods.
     */
    public function executePage() {

        // Get Page object.
        $pages_id = $this->input->get->pages_id ? (int) $this->input->get->pages_id : null;
        if (!$pages_id) {
            throw new WireException('Missing required GET param pages_id');
        }
        $page = $this->pages->get($pages_id);
        if (!$this->pageEditable($page)) {
            throw new WirePermissionException('Permission denied (Page not editable)');
        }
        $page_ids = [$pages_id];

        // Should date formatting occur?
        $defaults = static::$defaultData;
        $date_format = $this->date_format != $defaults['date_format'] ? $this->date_format : null;

        // Additional settings.
        $settings = $this->input->get->settings;

        // Include Repeater pages.
        $repeater_fields = [];
        foreach ($page->fields as $field) {
            if ($field->type instanceof FieldtypeRepeater) {
                $subfields = $this->templates->get($field->template_id)->versionControlFields;
                if ($subfields !== null && count($subfields)) {
                    foreach ($page->get($field->name) as $repeater_page) {
                        $page_ids[] = $repeater_page->id;
                        foreach ($subfields as $subfield) {
                            $repeater_fields[] = $subfield . "_repeater" . $repeater_page->id;
                        }
                    }
                }
            }
        }

        // Find values.
        $page_data = $this->store->revisions->getForPage($page_ids);

        // Fetch enabled fields.
        $enabled_fields = [];
        $template_fields = $page->template->versionControlFields;
        if ($template_fields !== null && count($template_fields)) {
            foreach ($template_fields as $field) {
                if (!$this->modules->VersionControl->enable_locked_fields) {
                    $field_object = $this->wire('fields')->get($field);
                    if ($field_object && $field_object->id) {
                        $inputfield = $field_object->getInputfield($page);
                        if (in_array($inputfield->collapsed, [7, 8])) {
                            continue;
                        }
                    }
                }
                $enabled_fields[] = $field->name;
            }
        }

        // Parse data.
        $data = [];
        foreach ($page_data as $row) {
            if (!in_array($row['field_name'], $enabled_fields)) {
                continue;
            }
            $item = [
                'users_id' => null,
                'username' => !empty($row['username']) ? $this->sanitizer->name($row['username']) : null,
                'revision' => $row['revision'] ?? null,
                'date' => $row['timestamp'] ?? null,
            ];
            if (isset($row['users_id']) && $user = $this->users->get((int) $row['users_id'])) {
                $item['users_id'] = $user->id;
                $item['username'] = $user->name;
            }
            if ($date_format && $item['date']) {
                $item['date'] = date($date_format, strtotime($item['date']));
            }
            $field_name = wire('sanitizer')->fieldName($row['field_name']);
            if ($row['pages_id'] != $page->id) {
                $field_name .= "_repeater" . $row['pages_id'];
            }
            if (!isset($data[$field_name])) {
                $data[$field_name] = [];
            }
            $data[$field_name][] = $item;
        }

        // Add empty containers for fields with no data?
        if (!empty($settings['empty'])) {
            $fields_with_data = array_keys($data);
            foreach ($enabled_fields as $enabled_field) {
                if (!in_array($enabled_field, $fields_with_data)) {
                    $data[$enabled_field] = [];
                }
            }
            foreach ($repeater_fields as $repeater_field) {
                if (!in_array($repeater_field, $fields_with_data)) {
                    $data[$repeater_field] = [];
                }
            }
        }

        // Return JSON or markup depending on provided settings.
        if (isset($settings['render']) && $settings['render'] === 'json') {
            header('Content-type: application/json');
            return json_encode($data, $settings['json_flags'] ?? 0);
        }
        return $this->wire(new \VersionControl\MarkupHelper())->renderFieldRevisions($data, $page);
    }

    /**
     * Render difference between two given revisions
     *
     * Revisions are defined via GET param 'revisions', which should contain two revision IDs
     * separated with a colon ('?revisions=41:42'). Field is defined via GET param 'field'.
     *
     * Diff is computed with JavaScript library diff_match_patch and returned as a HTML div element,
     * ID attribute (set as 'diff'), and some rudimentary CSS styles.
     *
     * @throws WireException if GET param field is missing.
     * @throws WireException if GET param revisions is missing.
     * @throws WireException if GET param revisions is invalid.
     * @throws WireException if GET param revisions includes same revision twice.
     * @throws WireException if requested field is not found.
     */
    public function executeDiff() {

        // Should date formatting occur?
        $defaults = static::$defaultData;
        $date_format = $this->date_format != $defaults['date_format'] ? $this->date_format : null;

        // Get field name and revision IDs.
        $field_name = $this->sanitizer->fieldName($this->input->get->field);
        if (!$field_name) throw new WireException("Missing required GET param field");
        $field_name = strpos($field_name, '_repeater') ? preg_replace('/_repeater[0-9]+$/', '', $field_name) : $field_name;
        $revisions = $this->input->get->revisions ?: null;
        if (!$revisions) throw new WireException("Missing required GET param revisions");

        // Get field object and label format (if applicable).
        $field = $this->fields->get('name=' . $field_name);
        if (!$field) {
            throw new WireException('Field not found');
        }
        $labelFieldName = "";
        $labelFieldFormat = "";
        if ($field->type == 'FieldtypePage') {
            if ($field->labelFieldName == '.') {
                // Custom format.
                $labelFieldName = 'title|name';
                $labelFieldFormat = $field->labelFieldFormat ?: $labelFieldName;
            } else {
                $labelFieldName = ($field->labelFieldName ?: 'title') . '|name';
            }
        }

        // Separate and validate revision IDs.
        list($r1, $r2) = explode(':', $revisions);
        $r1 = (int) $r1;
        $r2 = (int) $r2;
        if (!$r1 || !$r2) {
            throw new WireException('Revisions need to be provided in following format: 123:124');
        }
        if ($r1 == $r2) {
            throw new WireException('You need to provide separate source and target revisions');
        }

        // Find values.
        $field_data = $this->store->data->getForField($field_name, [$r1, $r2]);

        // Render output.
        $data = [];
        foreach ($field_data as $row) {
            $id = $row['revision'] == $r1 ? "r1" : "r2";
            if ($field->type == "FieldtypePage") {
                $data[$id] = [];
                if (preg_match("/^(?:[1-9][0-9]*\|?)*(?<!\|)$/", $row['data'])) {
                    $items = $this->pages->find('id=' . $row['data'] . ', include=all');
                    if ($items->count()) {
                        $item_ids = explode('|', $row['data']);
                        $use_get_markup = method_exists($items->first(), '___getMarkup');
                        foreach ($item_ids as $item_id) {
                            // Note that if Page has been removed it is disregarded; this is by
                            // design as restoring removed pages is currently not in our scope.
                            $item = $items->get('id=' . (int) $item_id);
                            if ($item && $item->id) {
                                $of = $item->of();
                                $item->of(true);
                                $data_row = $labelFieldFormat && $use_get_markup ? $item->getMarkup($labelFieldFormat) : $item->get($labelFieldName);
                                if (!mb_strlen($data_row)) {
                                    $data_row = $item->name;
                                }
                                $data[$id][] = [
                                    $item->id,
                                    $data_row,
                                ];
                                $item->of($of);
                            }
                        }
                    }
                }
            } else {
                echo "<textarea id='{$id}' class='revision' data-revision='{$row['id']}'>{$row['data']}</textarea>";
            }
        }
        if ($field->type == 'FieldtypePage') {
            // In the case of a Page field comparing strings makes little sense; comparing values
            // manually yields better results and more flexibility.
            $items = [];
            foreach ($data['r2'] as $key => $item) {
                if (isset($data['r1'][$key])) {
                    if ($data['r1'][$key][0] == $item[0]) {
                        $items[] = "<span title='#{$item[0]}'>{$item[1]}</span>";
                    } else {
                        $items[] = "<del title='#{$data['r1'][$key][0]}'>{$data['r1'][$key][1]}</del>";
                        $items[] = "<ins title='#{$item[0]}'>{$item[1]}</ins>";
                    }
                    unset($data['r1'][$key]);
                } else {
                    $items[] = "<ins title='{$item[0]}'>{$item[1]}</ins>";
                }
            }
            if (!empty($data['r1'])) {
                foreach ($data['r1'] as $item) {
                    $items[] = "<del title='#{$item[0]}'>{$item[1]}</del>";
                }
            }
            echo "<div id='diff'><ul class='page-diff'><li>" . implode('</li><li>', $items) . "</li></ul></div>";
        } else {
            echo "<div id='diff'></div>";
        }

        exit();
    }

    /**
     * Render output for a specific field in specific revision
     *
     * Revision ID is defined with GET param 'revision', field with GET param 'field'. Output is
     * either a rendered inputfield (HTML) or a JSON string.
     *
     * @throws WireException if GET param revision is missing.
     * @throws WireException if GET param field is missing.
     */
    public function executeField() {

        // Get and validate field name and revision ID.
        $revision_id = (int) $this->input->get->revision;
        if (!$revision_id) {
            throw new WireException("Missing required GET param revision");
        }
        $field_name = $this->sanitizer->fieldName($this->input->get->field);
        if (!$field_name) {
            throw new WireException("Missing required GET param field");
        }

        // Additional settings.
        $settings = $this->input->get->settings;

        // Find values.
        $field_data = $this->store->data->getForField($field_name, $revision_id);

        // Generate data (an associative array).
        $page = null;
        $field = null;
        $data = [];
        foreach ($field_data as $row) {
            $page = $page ?: $this->pages->get((int) $row['pages_id']);
            $field = $field ?: $this->fields->get((int) $row['fields_id']);
            if ($field->type == "FieldtypeDatetime") {
                $input = $field->getInputfield($page);
                $format = "$input->dateInputFormat $input->timeInputFormat";
                $row['data'] = date($format, $row['data']);
            }
            $data[$row['property']] = $row['data'];
        }

        // Bail out early if field was not found.
        if ($field === null) {
            exit;
        }

        // Choose a render method and exit with output.
        $default_language = $this->languages ? $this->languages->default : '';
        if (isset($settings['render']) && $settings['render'] === "Input") {
            $input = $field->getInputfield($page);
            foreach ($data as $data_key => $data_value) {
                if ($data_key == 'data' || preg_match('/^data[0-9]*$/', $data_key)) {
                    $data_lang = substr($data_key, 4);
                    if ($data_lang == $default_language) {
                        $data_lang = '';
                    }
                    if ($input instanceof InputfieldTextareas) {
                        $input->setAttribute('value' . $data_lang, $field->type->___wakeupValue($page, $field, $data_value));
                        continue;
                    }
                    if ($input instanceof InputfieldRepeater) {
                        throw new WireException("We don't currently support restoring entire Repeater fields");
                    }
                    $input->setAttribute('value' . $data_lang, $data_value);
                    continue;
                }
            }
            $filedata = [];
            $files = null;
            foreach ($data as $key => $value) {
                if (strpos($key, ".")) {
                    if (is_null($value)) {
                        $filedata[$field->name] = null;
                    } else if ($value) {
                        if (!$files) {
                            $files = $field->type->getBlankValue($this->page, $field);
                            $this->addHook('Pagefile::url', $this, 'hookPagefileUrl');
                            $this->addHook('Pagefile::filename', $this, 'hookPagefileFilename');
                            $this->addHookBefore('Pagefile::install', $this, 'hookPagefileInstall');
                            $this->addHookAfter('Pageimage::size', $this, 'hookPageimageSize');
                        }
                        $value = json_decode($value, true);
                        $file = $files->makeBlankItem();
                        $file->setFilename($value['filename']);
                        $file->description = $value['description'];
                        if (isset($value['tags']) && $field->useTags) {
                            $file->tags = $value['tags'];
                        }
                        $value['filename'] = substr($value['filename'], 0, 2) . '/' . $value['filename'];
                        $file->_version_control_basename = substr($value['filename'], strpos($value['filename'], ".")+1);
                        $file->_version_control_url = $this->store->files->getURL() . $value['filename'];
                        $file->_version_control_filename = $this->store->files->getPath() . $value['filename'];
                        $files->add($file);
                        $value['filename'] = $files->path . $value['filename'];
                        $filedata[$field->name][] = $value;
                    }
                }
            }
            if ($files) {
                $input->value = $files;
            }
            if ($filedata) {
                $filedata = json_encode($filedata);
                echo '<textarea class="version_control_filedata" name="version_control_filedata[]">' . $filedata . '</textarea>';
            }
            if ($page->template->name == 'role' && $input->name == 'permissions') {
                $input_permissions = $input;
                $input = new InputfieldForm();
                $input->add($input_permissions);
                $this->wire('modules')->get('ProcessRole');
            }
            if (in_array($input->collapsed, [7, 8])) {
                // Inputfield is locked (not editable)
                exit($input->renderValue());
            }
            exit($input->render());
        }

        // Output JSON
        header('Content-type: application/json');
        exit(json_encode($data));
    }

    /**
     * Prevent installing Pagefile if path is that of ProcessVersionControl
     *
     * @param HookEvent $event
     */
    protected function hookPagefileInstall(HookEvent $event) {
        if (strpos($event->arguments[0], $this->store->files->getPath()) !== 0) return;
        $event->object->basename = $event->arguments[0];
        $event->replace = true;
    }

    /**
     * Override Pageimage/Pagefile URL with custom one
     *
     * @param HookEvent $event
     */
    protected function hookPagefileUrl(HookEvent $event) {
        if (!$event->object->_version_control_url) return;
        $event->return = $event->object->_version_control_url;
    }

    /**
     * Override Pageimage/Pagefile filename with custom one
     *
     * @param HookEvent $event
     */
    protected function hookPagefileFilename(HookEvent $event) {
        if (!$event->object->_version_control_filename) return;
        $event->return = $event->object->_version_control_filename;
    }

    /**
     * Move resized pageimages (thumbs) to custom location
     *
     * @param HookEvent $event
     */
    protected function hookPageimageSize(HookEvent $event) {
        if (!$event->return->_version_control_filename) return;
        $filename = substr($event->return->basename, 0, 2) . '/variations/' . $event->return->basename;
        $event->return->_version_control_url = $this->store->files->getURL() . $filename;
        $event->return->_version_control_filename = $this->store->files->getPath() . $filename;
        rename($event->return->pagefiles->path() . $event->return->basename, $event->return->filename);
    }

    /**
     * Return (revert) specific page to given revision
     *
     * Revision is defined with GET param 'revision', page with GET param
     * 'pages_id'. Afterwards redirect user to page editor.
     */
    public function executeRestore() {

        // Replace current page content with that from given revision.
        $page = $this->getPageRevision('edit');
        $page->of(false);
        $page->save();
        $this->restored($page);

        // Redirect to page editor.
        $revision_id = (int) $this->input->get->revision;
        $this->session->message(sprintf(
            i18n::getText('Page reverted to revision #%d'),
            $revision_id
        ));
        $this->session->redirect($this->config->urls->admin . 'page/edit/?id=' . $page->id, false);
    }

    /**
     * Hookable method for when a page has been restored
     *
     * @param Page $page
     */
    protected function ___restored(Page $page) {}

    /**
     * Preview specific page in given revision
     *
     * Revision is defined with GET param 'revision', page with GET param 'pages_id'.
     */
    public function ___executePreview() {
        $page = $this->getPageRevision('view');
        exit($page->render());
    }

    /**
     * Set comment text for given revision
     *
     * Revision is defined by POST param 'revision' and comment text by POST param 'comment'.
     *
     * @throws WireException if revision doesn't exist
     * @return null|string Comment text or null.
     */
    public function executeComment(): ?string {

        // This only applies to POST requests.
        if ($_SERVER['REQUEST_METHOD'] !== "POST") {
            return null;
        }

        // Validate provided revision ID.
        $revision_id = (int) $this->input->post->revision;
        $revision = $this->store->revisions->getData($revision_id, ['timestamp']);
        if (!$revision) {
            throw new WireException("Revision doesn't exist: $revision_id");
        }

        // Update comment text and return updated value or null in case of a failure.
        return $this->store->revisions->update($revision_id, [
            'comment' => $this->input->post->comment,
        ])['comment'] ?? null;
    }

    /**
     * Return page as it was in given revision
     *
     * This method is used internally by the preview and restore methods. It stores the ID of the
     * requested revision as temporary property _version_control_parent to the Page object.
     *
     * @param string $permission Optional permission required ("view" or "edit").
     * @throws WireException if GET param pages_id is missing.
     * @throws WireException if GET param revision is missing.
     * @throws WireException if page defined by GET param pages_id doesn't exist.
     * @throws WirePermissionException if view access is expected and current user doesn't have the permission to view this page.
     * @throws WirePermissionException if edit access is expected and current user doesn't have the permission to edit this page.
     * @throws WireException if revision defined by GET param revision doesn't exist.
     * @return Page Page as it was in given revision.
     */
    protected function getPageRevision(string $permission = null): Page {

        // Get Page ID and revision ID.
        $pages_id = (int) $this->input->get->pages_id;
        if (!$pages_id) {
            throw new WireException("Missing required GET param pages_id");
        }
        $revision_id = (int) $this->input->get->revision;
        if (!$revision_id) {
            throw new WireException("Missing required GET param revision");
        }

        // Get Page object and check permissions.
        $page = $this->pages->get($pages_id);
        if (!$page->id) {
            throw new WireException(sprintf(
                i18n::getText('Page doesn\'t exist: %d'),
                $pages_id
            ));
        }
        if ($permission == 'view' && !$page->viewable()) {
            throw new WirePermissionException(i18n::getText('Permission denied (Page not viewable)'));
        }
        if ($permission == 'edit' && !$page->editable()) {
            throw new WirePermissionException(i18n::getText('Permission denied (Page not editable)'));
        }

        // Get revision timestamp from database.
        $revision = $this->store->revisions->getData($revision_id, ['timestamp']);
        if (!$revision) {
            throw new WireException(sprintf(
                i18n::getText('Revision doesn\'t exist: %d'),
                $revision_id
            ));
        }

        // Fetch snapshot of page at the time of given revision.
        $page->snapshot($revision['timestamp'], $revision_id);
        $page->_version_control_parent = $revision_id;

        return $page;
    }

    /**
     * Check if a Page is editable by current user
     *
     * @param Page $page
     * @return bool
     */
    protected function pageEditable(Page $page) {
        if ($page instanceof User) {
            $process = $this->wire('process');
            $this->wire('process', $this->user->id === $page->id && $this->user->hasPermission('profile-edit') ? 'ProcessProfile' : 'ProcessUser');
            $editable = $page->editable();
            $this->wire('process', $process);
            return $editable;
        }
        return $page->editable();
    }

}
