<?php

namespace ProcessWire;

use \VersionControl\i18n;

/**
 * Version Control
 *
 * This module adds support for storing, viewing, and restoring earlier versions (values) of fields and pages. Data is
 * automatically harvested for enabled fields and templates and stored in custom database tables. Stored data can be
 * viewed and restored via the Admin GUI (Page Edit) or the API.
 *
 * @copyright 2013-2021 Teppo Koivula
 * @license https://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License, version 2
 * @todo Regenerate data when fields are added to a tracked Template/Fieldgroup (see ProcessWire issue #1247).
 */
class VersionControl extends WireData implements Module, ConfigurableModule {

    /**
     * Default configuration for this module
     *
     * @var array
     */
    public static $defaultData = [
        'compatible_fieldtypes' => [
            'FieldtypeEmail',
            'FieldtypeDatetime',
            'FieldtypeText',
            'FieldtypeTextLanguage',
            'FieldtypeTextarea',
            'FieldtypeTextareas',
            'FieldtypeTextareaLanguage',
            'FieldtypePageTitle',
            'FieldtypePageTitleLanguage',
            'FieldtypeCheckbox',
            'FieldtypeInteger',
            'FieldtypeFloat',
            'FieldtypeURL',
            'FieldtypePage',
            'FieldtypeModule',
            'FieldtypeFile',
            'FieldtypeImage',
            'FieldtypeSelector',
            'FieldtypeOptions',
        ],
        'enabled_templates' => [],
        'enable_all_templates' => false,
        'enable_locked_fields' => false,
    ];

    /**
     * Container for field data
     *
     * @var array
     */
    protected $page_data = [];

    /**
     * Container for local variables
     * 
     * @var array
     */
    protected $data = [];

    /**
     * Container for hash format filenames within image inputfields
     * 
     * @var array
     */
    protected $hash_map = [];

    /**
     * Container for runtime user information cache
     * 
     * @var array
     */
    protected $users_cache = [];

    /**
     * Name of the revisions database table
     *
     * Revisions table keeps track of revision numbers, which are system wide, and stores important metadata, such as
     * dates, user IDs, and page IDs.
     *
     * @var string
     */
    const TABLE_REVISIONS = 'version_control__revisions';

    /**
     * Name of the database table containing actual field values
     *
     * @var string
     */
    const TABLE_DATA = 'version_control__data';

    /**
     * Name of the databae table containing metadata for stored files
     *
     * Having file metadata stored in the database makes tasks such as mime type checking and fetching file sizes and
     * file hashes fast. Another benefit is easier and more efficient cleanup for orphaned files.
     *
     * @var string
     */
    const TABLE_FILES = 'version_control__files';

    /**
     * Name of the database table connecting file metadata with field values
     *
     * @var string
     */
    const TABLE_DATA_FILES = 'version_control__data_files';

    /**
     * Populate the default config data
     *
     * ProcessWire will automatically overwrite it with anything the user has specifically configured. This is done in
     * construct() rather than init() because ProcessWire populates config data after construct(), but before init().
     */
    public function __construct() {
        foreach (static::$defaultData as $key => $value) {
            $this->$key = $value;
        }
    }

    /**
     * Module configuration
     *
     * Note: some configuration inputfields are pulled from the companion modules Process Version Control and Version
     * Control Cleanup. This makes configuration options easier to grasp and harder to miss by accident.
     *
     * @param array $data
     * @return InputfieldWrapper
     */
    public function getModuleConfigInputfields(array $data): InputfieldWrapper {
        $this->initClassLoader();
        return $this->wire(new \VersionControl\ModuleConfig($data))->getFields();
    }

    /**
     * Initialization function
     */
    public function init() {

        // Init class autoloader.
        $this->initClassLoader();

        // Handle saving config data for the companion modules.
        $this->addHookBefore('Modules::saveModuleConfigData(VersionControl)', $this, 'saveConfigData');

        // Regenerate base data when enabled templates change.
        $this->addHookAfter('Modules::saveModuleConfigData(VersionControl)', $this, 'regenerateData');

        if ($this->enable_all_templates || !empty($this->enabled_templates)) {

            // Add hooks that get and store data.
            $this->addHookBefore('Pages::saveReady', $this, 'restoreFiles');
            $this->addHook('Pages::saveReady', function(HookEvent $event) {
                $this->readPageData($event->arguments[0]);
            });
            $this->addHook('Pages::saveFieldReady', function(HookEvent $event) {
                $this->readPageData($event->arguments[0], $event->arguments[1]);
            });
            $this->addHook('Pages::saved', function(HookEvent $event) {
                $this->savePageData($event->arguments[0]);
            });
            $this->addHook('Pages::savedField', function(HookEvent $event) {
                $this->savePageData($event->arguments[0], $event->arguments[1]);
            });

            // Add hooks that load additional scripts and styles.
            $this->addHookAfter('ProcessPageEdit::execute', $this, 'loadResources');
            $this->addHookAfter('ProcessProfile::execute', $this, 'loadResources');

            // If we're editing a full page, add hook that builds the history tab.
            if (!$this->input->get->field && !$this->input->get->fields) {
                $this->addhookAfter('ProcessPageEdit::buildForm', $this, 'addHistoryTab');
            }

            // Add hooks that alter the output of image and file inputfields on the fly.
            $this->addHookBefore('InputfieldImage::renderItem', $this, 'captureHashes');
            $this->addHookBefore('InputfieldFile::renderItem', $this, 'captureHashes');
            $this->addHookAfter('InputfieldFile::renderList', $this, 'replaceHashes');

            // Add hook that removes hashes within text content of a rendered page.
            $this->addHookAfter('Page::render', $this, 'replaceTextHashes');

            // Add new property versionControlFields to Template object.
            $this->addHookProperty('Template::versionControlFields', $this, 'versionControlFields');

            // Add new property versionControlRevision to Page object.
            $this->addHookProperty('Page::versionControlRevision', $this, 'versionControlRevision');

            // Add new method versionControlRevisions to Page object.
            $this->addHook('Page::versionControlRevisions', $this, 'versionControlRevisions');
        }
    }

    /**
     * Add VersionControl namespace to ProcessWire's class autoloader
     */
    public function initClassLoader() {
        if ($this->wire('classLoader')->hasNamespace('VersionControl')) return;
        $this->wire('classLoader')->addNamespace(
            'VersionControl',
            $this->wire('config')->paths->get('VersionControl') . 'lib/'
        );
    }

    /**
     * Capture hash format filenames from an image inputfield
     *
     * @param HookEvent $event
     */
    protected function captureHashes(HookEvent $event) {

        // Get item being rendered.
        $item = $event->arguments[0];
        if (!$item->_version_control_basename) return;

        // Bail out early if this particular hash is already stored.
        if (isset($this->hash_map['>' . $item->basename . '<'])) return;

        // Full filename.
        $this->hash_map['>' . $item->basename . '<'] = '>' . $item->_version_control_basename . '<';

        // Filename without extension (for InputfieldImage).
        $basename = mb_substr($item->basename, 0, mb_strrpos($item->basename, '.'));
        $version_control_basename = mb_substr($item->_version_control_basename, 0, mb_strrpos($item->_version_control_basename, '.'));
        $this->hash_map['>' . $basename . '<'] = '>' . $version_control_basename . '<';

        // Shortened filename (for InputfieldFile). Note: this does the same thing as the
        // InputfieldFile getDisplayBasename() method and might be removed at some point.
        if (!$event->object->noShortName && mb_strlen($item->basename) > 25) {
            $ext = '.' . $item->ext;
            $basename = mb_substr(basename($item->basename, $ext), 0, 25-(mb_strlen($ext)+1)) . '&hellip;' . ltrim($ext, '.');
            $version_control_basename = $item->_version_control_basename;
            if (mb_strlen($version_control_basename) > 25) {
                $version_control_basename = mb_substr(
                    basename($version_control_basename, $ext),
                    0,
                    25 - (mb_strlen($ext) + 1)
                ) . "&hellip;" . ltrim($ext, '.');
            }
            $this->hash_map['>' . $basename . '<'] = '>' . $version_control_basename . '<';
        }
    }

    /**
     * Replace previously captured hash filenames with clean basenames
     *
     * @param HookEvent $event
     */
    protected function replaceHashes(HookEvent $event) {
        if (empty($this->hash_map)) return;
        $event->return = str_replace(
            array_keys($this->hash_map),
            array_values($this->hash_map),
            $event->return
        );
    }

    /**
     * Attempt to replace hashes within text content of rendered page output
     * 
     * This only applies to preview mode, i.e. when we're checking out the contents of a page in a specific revision.
     * We're also going to leave those paths as-is that look like full URLs, because we don't want to prevent
     * embedding images etc. from the version control file directory.
     *
     * @todo Consider making this feature configurable: on/off, custom rule?
     * @param HookEvent $event
     */
    protected function replaceTextHashes(HookEvent $event) {
        if (!$this->input->get->revision) return;
        $url = preg_quote($this->modules->VersionControl->url, "#");
        $event->return = preg_replace("#(?<!{$url}[a-z0-9]{2}/)[a-z0-9]{40}\.(?![a-z0-9\._-]*(\"|'))#i", "", $event->return);
    }

    /**
     * Update file fields if Page has _version_control_filedata or if POST param version_control_filedata is set
     * 
     * Note: Page property is set by PageSnapshot when used via API while POST data is added by ProcessVersionControl
     * when editing the Page.
     *
     * @param HookEvent $event
     */
    protected function restoreFiles(HookEvent $event) {

        // Get Page and prepare file data.
        $page = $event->arguments[0];
        $page->_version_control_filedata = $page->_version_control_filedata ?: $this->input->post->version_control_filedata;
        if (!$page->_version_control_filedata) {
            return;
        }

        // Get current (uncached) version of the Page.
        $page_current = clone($page);
        $page_current->uncache();

        // Remove hooks used by PageSnapshot to prevent installing pagefiles.
        $this->modules->PageSnapshot->removePagefileHooks();

        foreach ($page->_version_control_filedata as $filedata) {
            $filedata = json_decode($filedata, true);
            foreach ($filedata as $field => $items) {

                // Remove old files from disk and then from field itself.
                foreach ($page_current->$field as $file) $file->unlink();
                $page->$field->deleteAll();

                // Note: saving the field at this point helps avoid naming conflicts between new
                // and old files, and prevents restored files from being accidentally removed.
                $this->pages->___saveField($page, $field, [
                    'quiet' => true,
                    'noHooks' => true,
                ]);

                // Add new files to the field. Field copies these files to the correct location
                // automatically, but we'll have to rename them to original filename by removing
                // the hash prefixes added for storage.
                if (is_array($items)) {
                    foreach ($items as $item) {
                        $page->$field->add($item['filename']);
                        $basename = basename($item['filename']);
                        $clean_basename = substr($basename, strpos($basename, '.')+1);
                        $page->$field->last()->rename(str_replace($basename, $clean_basename, $item['filename']));
                        $page->$field->last()->description = $item['description'];
                        $page->$field->last()->modified = $item['modified'];
                        $page->$field->last()->created = $item['created'];
                        if (isset($item['tags'])) {
                            $page->$field->last()->tags = $item['tags'];
                        }
                    }
                }
            }
        }

        // File data is no longer needed so we'll discard it.
        unset($page->_version_control_filedata);
    }

    /**
     * Read data from a Page for storage
     *
     * @param Page $page
     * @param Field|null $field
     * @param bool $force
     */
    protected function readPageData(Page $page, ?Field $field = null, bool $force = false) {

        // If Page has no ID, it's currently being added.
        $page_id = $page->id ?: 0;

        // Check if tracking values has been enabled for the template of current page, or (in the
        // case of Repeater pages) template of the containing page.
        $template = $page->template;
        if ($page instanceof RepeaterPage) {
            $template = $page->getForPage()->template;
        }
        if (!$force && !$this->isEnabledTemplate($template)) return;

        if ($force || $page->isChanged()) {
            foreach ($page->template->fields as $page_field) {

                // Check if we should skip this field.
                if ($field && $page_field->id != $field->id) continue;
                if (!$force && !$page->isChanged($page_field->name)) continue;
                if (!$page->id && $page_field->type instanceof FieldtypeFile) continue;
                if (!in_array($page_field->type, $this->compatible_fieldtypes)) continue;
                if (!empty($this->enabled_fields) && !in_array($page_field->id, $this->enabled_fields)) continue;

                // Get data from the Page object.
                $data = $page->get($page_field->name);

                // Continue only if either the page in question exists (i.e. old field was cleared)
                // or page is new and field has value.
                if ($page->id || !is_null($data) && $data != "") {
                    if (!isset($this->page_data[$page_id])) {
                        $this->page_data[$page_id] = [];
                    }
                    $data_array = [
                        'data' => $data,
                    ];
                    if ($data instanceof Pagefiles) {
                        // Note: originally 'sort' value of each item was used instead of a custom
                        // counter, but that's not always available when working over the API.
                        $count = 0;
                        foreach ($data as $item) {
                            $data_item = [
                                'original_filename' => $item->filename, 
                                'filename' => hash_file('sha1', $item->filename) . "." . $item->basename,
                                'description' => $item->description,
                                'modified' => $item->modified,
                                'created' => $item->created,
                            ];
                            if ($page_field->useTags) {
                                $data_item['tags'] = $item->tags;
                            }
                            $data_array[$count.'.data'] = json_encode($data_item);
                            ++$count;
                        }
                        if (empty($data_array)) {
                            $data_array['0.data'] = null;
                        }
                    } else if ($data instanceof LanguagesPageFieldValue) {
                        foreach ($data->getChanges() as $key) {
                            if ($key == 'data') continue;
                            $data_array[$key] = $data->getLanguageValue(str_replace('data', '', $key));
                        }
                    }
                    $this->page_data[$page_id][$page_field->id] = $data_array;
                }
            }
        }
    }

    /**
     * Store data in database (and disk, in case files or images are involved)
     *
     * @param Page $page
     * @param Field|null $field
     */
    protected function savePageData(Page $page, ?Field $field = null) {

        // Bail out early if no page data exists.
        if (!$this->page_data) return;

        // Bail out early if current page is a repeater parent ("for-page-n" or "for-field-n").
        if ($page->template == 'admin' && strpos($page->name, 'for-') === 0) return;

        // Fetch page data.
        if (!isset($this->page_data[$page->id]) && isset($this->page_data[0])) {
            // Handle new pages; '0' is a placeholder required if we want to store even the initial
            // values of fields under version control.
            $this->page_data[$page->id] = $this->page_data[0];
            unset($this->page_data[0]);
        }
        $page_data = $this->page_data[$page->id] ?? null;
        if ($field) {
            $page_data = isset($page_data[$field->id]) ? [
                $field->id => $page_data[$field->id],
            ] : null;
        }
        if (!$page_data) return;

        // Fetch current revision (parent) and user details.
        $parent = $page->_version_control_parent;
        $users_id = $this->user->id;
        $username = $this->user->name;

        // Revision ID placeholder.
        $revisions_id = 0;

        foreach ($page_data as $fields_id => $field_data) {

            // If revision isn't assigned yet, get next available revision ID.
            if (!$revisions_id) {
                $stmt = $this->database->prepare("INSERT INTO " . self::TABLE_REVISIONS . " (parent, pages_id, users_id, username, timestamp) VALUES (:parent, :pages_id, :users_id, :username, :timestamp)");
                $stmt->bindValue(':parent', $parent ?: null, \PDO::PARAM_INT);
                $stmt->bindValue(':pages_id', $page->id, \PDO::PARAM_INT);
                $stmt->bindValue(':users_id', $users_id, \PDO::PARAM_INT);
                $stmt->bindValue(':username', $username, \PDO::PARAM_STR);
                $stmt->bindValue(':timestamp', date('Y-m-d H:i:s'), \PDO::PARAM_STR);
                $stmt->execute();
                $revisions_id = $this->database->lastInsertId();
                $page->_version_control_revision = $revisions_id;
                // If parent isn't assigned yet, use ID of previous revision.
                if (!$parent) {
                    $stmt = $this->database->prepare("SELECT id FROM " . self::TABLE_REVISIONS . " WHERE pages_id = :pages_id AND id < :revisions_id ORDER BY id DESC LIMIT 1");
                    $stmt->bindValue(':pages_id', $page->id, \PDO::PARAM_INT);
                    $stmt->bindValue(':revisions_id', $revisions_id, \PDO::PARAM_INT);
                    $stmt->execute();
                    $result = $stmt->fetch(\PDO::FETCH_ASSOC);
                    if ($result) {
                        $stmt = $this->database->prepare("UPDATE " . self::TABLE_REVISIONS . " SET parent = :parent WHERE id = :revisions_id");
                        $stmt->bindValue(':parent', (int) $result['id'], \PDO::PARAM_INT);
                        $stmt->bindValue(':revisions_id', $revisions_id, \PDO::PARAM_INT);
                        $stmt->execute();
                    }
                }
            }

            // Insert field data to another table.
            foreach ($field_data as $property => $data) {

                // FieldtypeTextareas
                if ($data instanceof TextareasData || $data instanceof \ProcessWire\TextareasData) {
                    $field = $data->getField();
                    $data = $field->type->___sleepValue($page, $field, $data);
                }

                $file_id = null;

                // Dot means that this is multipart property (n.data), which can (at least for the time being) used to
                // identify file/image fields.
                if (strpos($property, ".") && !is_null($data)) {

                    // Decode JSON data to get proper file information; copy the original file to storage (unless it's
                    // already there).
                    $data = json_decode($data, true);
                    $dir = $this->path . substr($data['filename'], 0, 2) . "/";
                    $file = $dir . $data['filename'];

                    // If this is an existing file, fetch ID from files table; otherwise store as a new file and add
                    // a row to said table.
                    if (is_file($file)) {
                        $stmt = $this->database->prepare("SELECT id FROM " . self::TABLE_FILES . " WHERE filename = :filename");
                        $stmt->bindValue(':filename', $data['filename'], \PDO::PARAM_STR);
                        $stmt->execute();
                        $result = $stmt->fetch(\PDO::FETCH_ASSOC);
                        $file_id = $result['id'];
                    } else {
                        if (!is_dir($dir)) wireMkdir($dir . "variations", true);
                        copy($data['original_filename'], $file);
                        $mime_type = '';
                        if ($this->use_fileinfo) {
                            // PECL fileinfo extension is not enabled by default in Windows, so check for that first.
                            $finfo = finfo_open(FILEINFO_MIME_TYPE);
                            $mime_type = finfo_file($finfo, $file);
                            finfo_close($finfo);
                        } else if ($this->use_mime_content_type) {
                            $mime_type = mime_content_type($file);
                        }
                        $size = filesize($file);
                        if (empty($size)) {
                            $size = 0;
                        }
                        $stmt = $this->database->prepare("INSERT INTO " . self::TABLE_FILES . " (filename, mime_type, size) VALUES (:filename, :mime_type, :size)");
                        $stmt->bindValue(':filename', $data['filename'], \PDO::PARAM_STR);
                        $stmt->bindValue(':mime_type', $mime_type, \PDO::PARAM_STR);
                        $stmt->bindValue(':size', $size, \PDO::PARAM_INT);
                        $stmt->execute();
                        $file_id = $this->database->lastInsertId();
                    }
                    unset($data['original_filename']);

                    // Re-encode the JSON data.
                    $data = json_encode($data);
                }
                $stmt = $this->database->prepare("INSERT INTO " . self::TABLE_DATA . " (revisions_id, fields_id, property, data) VALUES (:revisions_id, :fields_id, :property, :data)");
                $stmt->bindValue(':revisions_id', $revisions_id, \PDO::PARAM_INT);
                $stmt->bindValue(':fields_id', $fields_id, \PDO::PARAM_INT);
                $stmt->bindValue(':property', $property, \PDO::PARAM_STR);
                $stmt->bindValue(':data', $data, \PDO::PARAM_STR);
                $stmt->execute();
                if ($file_id) {
                    // If data row is related to a file, add a new row to the junction table.
                    $data_id = $this->database->lastInsertId();
                    $stmt = $this->database->prepare("INSERT INTO " . self::TABLE_DATA_FILES . " (data_id, files_id) VALUES (:data_id, :file_id)");
                    $stmt->bindValue(':data_id', $data_id, \PDO::PARAM_INT);
                    $stmt->bindValue(':file_id', $file_id, \PDO::PARAM_INT);
                    $stmt->execute();
                }
            }

            // Remove processed items from the page data.
            unset($this->page_data[$page->id][$fields_id]);
            if (!$this->page_data[$page->id]) unset($this->page_data[$page->id]);

            // Enforce the row limit setting.
            $this->cleanupExcessRows($page->id, $fields_id);

            // Clear revision cache.
            $page->_version_control_revisions = null;
        }
    }

    /**
     * Load resources (scripts/styles) in admin
     *
     * @param HookEvent $event
     */
    protected function loadResources(HookEvent $event) {

        // This only applies to GET requests.
        if (!isset($_SERVER['REQUEST_METHOD']) || $_SERVER['REQUEST_METHOD'] !== "GET") return;

        // Make sure that current user has the version-control permission.
        if (!$this->user->hasPermission('version-control')) return;

        // Make sure that value tracking is enabled for template of the page currently being edited.
        $page = $this->process->getPage();
        if (!$page || !$page->id || !$this->isEnabledTemplate($page->template)) return;

        // Scripts and styles.
        $module_url = $this->config->urls->get('VersionControl');
        $version = $this->modules->getModuleInfoProperty('VersionControl', 'version');
        $this->config->styles->add($module_url . 'res/css/VersionControl.min.css?v=' . $version);
        $this->config->scripts->add($module_url . 'res/js/VersionControl.min.js?v=' . $version);

        // Settings and translations.
        $process = $this->modules->getModuleID('ProcessVersionControl');
        $process_page = $this->pages->get('process=' . $process);
        $this->config->js('VersionControl', [
            'i18n' => [
                'compareWithCurrent' => i18n::getText('Compare with current'),
                'editDisabled' => i18n::getText('Editing this data is currently disabled. Restore it by saving the page or switch to current version first.'),
                'commentPrompt' => i18n::getText('Type in comment text for this revision (max 255 characters)'),
                'closePreview' => i18n::getText('This is the page as it appeared on %s. Click here to close the preview.'),
                'confirmRestore' => i18n::getText('Are you sure that you want to revert this page to an earlier revision?'),
                'diffSideBySide' => i18n::getText('Show side by side'),
                'diffList' => i18n::getText('Show as a list'),
                'noDiff' => i18n::getText('There is no difference between these revisions.'),
                'toggleRevisions' => i18n::getText('Toggle a list of revisions'),
            ],
            'diff' => [
                'timeout' => (int) $this->diff_timeout,
                'editCost' => (int) $this->diff_efficiency_cleanup_edit_cost,
                'cleanup' => ucfirst($this->diff_cleanup),
            ],
            'pageID' => $page->id,
            'moduleDir' => $this->config->urls->get('VersionControl'),
            'processPage' => $process_page->url(),
        ]);
    }

    /**
     * Add the 'history' tab to the Page Edit form
     *
     * @param HookEvent $event
     */
    protected function addHistoryTab(HookEvent $event) {

        // Make sure that current user has the version-control permission.
        if (!$this->user->hasPermission('version-control')) return;

        // Fetch the page being edited.
        $form = $event->return;
        $page = $this->pages->get((int) $form->get('id')->value);

        // Make sure that version control is enabled for the template of the page being edited.
        if (!$this->isEnabledTemplate($page->template)) return;

        // Fetch history data for the page being edited.
        $limit = 25;
        $start = $this->input->get->page ? ($this->input->get->page-1)*$limit : 0;
        $data = $this->getHistory($page, $start, $limit, [
            'users_id' => $this->input->get->users_id,
        ]);
        if (!$data) return;

        // Adjust the position of the history tab.
        $this->addHookAfter('ProcessPageEdit::getTabs', $this, 'adjustTabOrder');

        // Insert the tab to the Page Edit form.
        $form->prepend($this->wire(new \VersionControl\MarkupHelper())->getHistoryTab($data, $page));
        $event->return = $form;

        // Load scripts.
        $module_url = $this->wire('config')->urls->get('VersionControl');
        $version = $this->modules->getModuleInfoProperty('VersionControl', 'version');
        $this->wire('config')->scripts->add($module_url . 'res/js/HistoryTab.min.js?v=' . $version);
    }

    /**
     * Adjust the position of the history tab in Process Page Edit
     *
     * @param HookEvent $event
     */
    protected function adjustTabOrder(HookEvent $event) {

        // Make sure that current user has the version-control permission.
        if (!$this->user->hasPermission('version-control')) return;

        // Get position for the history tab.
        $pos = false;
        $keys = array_keys($event->return);
        if (($pos = array_search('ProcessPageEditSettings', $keys)) !== false) {
            $pos += 1;
        } else {
            if (($pos = array_search('ProcessPageEditDelete', $keys)) === false) {;
                $pos = array_search('ProcessPageEditView', $keys);
            }
        }
        if ($pos === false) return;

        // Adjust tab position.
        $event->return = array_merge(
            array_slice($event->return, 0, $pos, true), [
                'VersionControlHistory' => i18n::getText('History'), // Tab Label: History
            ], array_slice($event->return, $pos, null, true)
        );
    }

    /**
     * Get full history of a specific page as an array
     *
     * This method is similar to Page::versionControlRevisions(), but in this case the return value includes more
     * details, supports pagination, and takes possible filters into account.
     *
     * While $start and $limit are optional, including limit is recommended. Without a sensible limit the result set
     * can be very large, leading to high memory consumption and slow load time.
     *
     * @param Page $page
     * @param int $start
     * @param int $limit
     * @param array $filters array of filters, currently only possible key being "users_id"
     * @return array|null null on failure, array consisting of keys "data", "total", "start", and "limit" on success
     */
    public function getHistory(Page $page, int $start = null, int $limit = null, array $filters = []): ?array {

        // Return null in case of a disabled template.
        if (!$this->isEnabledTemplate($page->template)) {
            return null;
        }

        // Cache usernames for later use.
        if (empty($this->users_cache)) {
            $this->cacheUsers($page);
        }

        // Gather WHERE rules (page, filters).
        $where = [];
        $where['r.pages_id = :pages_id'] = [':pages_id', $page->id, \PDO::PARAM_INT];
        if (isset($filters['users_id']) && $filters['users_id'] == (int) $filters['users_id']) {
            $where['r.users_id = :users_id'] = [':users_id', $filters['users_id'], \PDO::PARAM_INT];
        }
        $where_str = "WHERE " . implode(" AND ", array_keys($where));

        // Total count of rows in database table.
        $stmt = $this->database->prepare("SELECT COUNT(*) AS total FROM " . self::TABLE_REVISIONS . " r $where_str");
        foreach ($where as $value) $stmt->bindValue($value[0], $value[1], $value[2]);
        $stmt->execute();
        $result = $stmt->fetch(\PDO::FETCH_ASSOC);
        $total = (int) $result['total'];

        // Put together a LIMIT clause.
        if ($limit) {
            $limit = (int) $limit;
            $start = (int) $start;
            if ($start > $total) {
                $start = $total-$limit;
                if ($start < 0) $start = 0;
            }
        }

        // Fetch and parse history rows.
        $sql = "
        SELECT r.id, r.users_id, r.username, GROUP_CONCAT(CONCAT_WS(':', d.fields_id, d.property)) changes, r.timestamp, r.comment
        FROM " . self::TABLE_REVISIONS . " r
        LEFT OUTER JOIN " . self::TABLE_DATA . " d
        ON d.revisions_id = r.id
        $where_str
        GROUP BY r.id
        ORDER BY r.timestamp DESC, r.id DESC
        ";
        if ($limit) {
            $sql .= " LIMIT :start, :limit";
        }
        $stmt = $this->database->prepare($sql);
        foreach ($where as $value) {
            $stmt->bindValue($value[0], $value[1], $value[2]);
        }
        if ($limit) {
            $stmt->bindValue(':start', $start, \PDO::PARAM_INT);
            $stmt->bindValue(':limit', $limit, \PDO::PARAM_INT);
        }
        $stmt->execute();
        $data = [];
        $properties = [];
        while ($row = $stmt->fetch(\PDO::FETCH_ASSOC)) {
            if ($row['changes']) {
                $changes = [];
                $changes_fields = explode(",", $row['changes']);
                foreach ($changes_fields as $changes_field) {
                    list($field_id, $property) = explode(":", $changes_field);
                    if (strpos($property, ".") !== false) {
                        // Extra dot only applies to file fields (0.data, 1.data, etc.)
                        list($count, $property) = explode(".", $property);
                        $changes_field = $field_id . ":" . $property;
                    }
                    if ($field = $this->fields->get((int) $field_id)) {
                        // @todo Consider omitting some fields; either all hidden fields (at least for non-superusers
                        // and non-CLI use), or those defined in module config.
                        if ($this->wire('modules')->isInstalled('LanguageSupport')) {
                            if (strpos($property, "data") === 0 && $property != 'data') {
                                if (!isset($properties[$property])) {
                                    $language_id = (int) substr($property, 4);
                                    $language = $this->languages->get($language_id);
                                    if (!$language->id) continue;
                                    $properties[$property] = $language->get('title|name');
                                }
                            }
                            $label = 'label' . ($this->user->language->isDefault() ? '' : $this->user->language->id);
                            $changes[$changes_field] = $field->get($label . "|name") . (isset($properties[$property]) ? " (" . $properties[$property] . ")" : "");
                        } else {
                            if (strpos($property, "data") === 0 && $property != 'data') continue;
                            $changes[$changes_field] = $field->get("label|name");
                        }
                    }
                }
                $row['changes'] = implode(', ', $changes);
            }
            $data[] = [
                'id' => (int) $row['id'],
                'users_id' => (int) $row['users_id'],
                'username' => isset($this->users_cache[$row['users_id']]) ? $this->users_cache[$row['users_id']] : $row['username'],
                'changes' => $row['changes'],
                'timestamp' => $row['timestamp'],
                'comment' => $this->sanitizer->entities($row['comment']),
            ];
        }

        return [
            'data' => $data,
            'total' => $total,
            'start' => $start,
            'limit' => $limit,
        ];
    }

    /**
     * Generate runtime users cache
     *
     * @param Page $page
     */
    protected function cacheUsers(Page $page) {
        $users = [];
        $stmt = $this->database->prepare("SELECT DISTINCT users_id FROM " . self::TABLE_REVISIONS . " WHERE pages_id = :pages_id");
        $stmt->bindValue(':pages_id', $page->id, \PDO::PARAM_INT);
        $stmt->execute();
        while ($row = $stmt->fetch(\PDO::FETCH_ASSOC)) {
            $user = $this->wire('users')->get((int) $row['users_id']);
            if ($user->id) {
                $users[$user->name] = $user->id;
                continue;
            }
            $stmt = $this->database->prepare("SELECT username FROM " . self::TABLE_REVISIONS . " WHERE users_id = :users_id LIMIT 1");
            $stmt->bindValue(':users_id', $row['users_id'], \PDO::PARAM_INT);
            $stmt->execute();
            $user = $stmt->fetch(\PDO::FETCH_ASSOC);
            $users[$user['username']] = $row['users_id'];
        }
        ksort($users);
        $this->users_cache = array_flip($users);
    }

    /**
     * Get users cache
     *
     * This method automatically populates the users cache if it doesn't exist yet.
     *
     * @param Page $page
     * @return array
     */
    public function getUsersCache(Page $page) {
        if (empty($this->users_cache)) {
            $this->users_cache = $this->cacheUsers($page);
        }
        return $this->users_cache;
    }

    /**
     * Find out which fields belonging to current template have version control enabled
     *
     * This method adds new "versionControlFields" property to Template objects.
     *
     * @param HookEvent $event
     */
    protected function versionControlFields(HookEvent $event) {

        // Bail out early if template isn't version controlled.
        $template = $event->object;
        if (!$this->isEnabledTemplate($template)) return;

        // If enabled_fields is empty, all fields are enabled.
        if (empty($this->enabled_fields)) {
            $event->return = $template->fields;
            return;
        }

        $fields = new Fieldgroup();
        foreach ($this->enabled_fields as $field) {
            if ($template->hasField($field)) {
                $fields->add($this->fields->get($field));
            }
        }

        $event->return = $fields;
    }

    /**
     * Find out the revision number of current page
     *
     * This method adds new "versionControlRevision" property to Page objects.
     *
     * @param HookEvent $event
     */
    protected function versionControlRevision(HookEvent $event) {

        // Bail out early if the template of current page is not version controlled.
        $page = $event->object;
        if (!$this->isEnabledTemplate($page->template)) return;

        $revision = (int) $page->_version_control_revision;
        if (!$revision) {
            $stmt = $this->database->prepare("SELECT id FROM " . self::TABLE_REVISIONS . " WHERE pages_id = :pages_id ORDER BY id DESC LIMIT 1");
            $stmt->bindValue(':pages_id', (int) $page->id, \PDO::PARAM_INT);
            $stmt->execute();
            $result = $stmt->fetch(\PDO::FETCH_ASSOC);
            if ($result) {
                $revision = (int) $result['id'];
                $page->_version_control_revision = $revision;
            }
        }

        $event->return = $revision ?: null;
    }

    /**
     * Find existing revisions of current page
     *
     * Adds new method Page::versionControlRevisions(). This method accepts optional $limit param (int), which defines
     * how many revisions should be returned. Returns an array with revision IDs as keys and datetimes as values, with
     * current revision always as the first array item:
     *
     * [
     *     3 => '2014-01-01 01:15:00', // current revision
     *     2 => '2014-01-01 01:10:00',
     *     1 => '2014-01-01 01:00:00',
     *     // etc.
     * ];
     *
     * @param HookEvent $event
     */
    protected function versionControlRevisions(HookEvent $event) {

        // Bail out early if the template of current page is not version controlled.
        $page = $event->object;
        if (!$this->isEnabledTemplate($page->template)) return;

        // Limit argument defines how many revisions can be returned.
        $limit = null;
        if (isset($event->arguments[0]) && (int) $event->arguments[0] > 0) {
            $limit = (int) $event->arguments[0];
        }

        // Placeholder for returned data.
        $revisions = null;

        // Attempt to fetch revisions from cache.
        if (is_array($page->_version_control_revisions)) {
            $cache = $page->_version_control_revisions;
            if ($cache['limit'] == $limit) {
                $revisions = $cache['revisions'];
            } else if ($limit && $cache['limit'] > $limit) {
                $revisions = array_slice($cache['revisions'], 0, $limit, true);
            }
        }

        // If there were no revisions in cache, fetch from the database (with limit applied if one was provided).
        if (!is_array($revisions)) {
            $sql = "SELECT id, timestamp FROM " . self::TABLE_REVISIONS . " WHERE pages_id = :pages_id ORDER BY id DESC";
            if ($limit) $sql .= " LIMIT :limit";
            $stmt = $this->database->prepare($sql);
            $stmt->bindValue(':pages_id', (int) $page->id, \PDO::PARAM_INT);
            if ($limit) $stmt->bindValue(':limit', (int) $limit, \PDO::PARAM_INT);
            $stmt->execute();
            $revisions = $stmt->fetchAll(\PDO::FETCH_KEY_PAIR);
            $page->_version_control_revisions = [
                'limit' => $limit,
                'revisions' => $revisions,
            ];
        }

        $event->return = $revisions;
    }

    /**
     * Set up when the module is installed
     *
     * @throws WireException if VersionControlForTextFields module is found
     */
    public function install() {

        // If Version Control For Text Fields is found, cancel installation to avoid a conflict.
        if (is_dir($this->config->paths->siteModules . "VersionControlForTextFields")) {
            throw new WireException("VersionControlForTextFields has to be removed first");
        }

        // Create database tables and attempt to import Version Control for Text Fields data.
        $this->initClassLoader();
        $db = $this->wire(new \VersionControl\DatabaseHelper());
        $db->createTables();
        $db->versionControlForTextFieldsImport();
    }

    /**
     * Clean up when the module is unintalled
     */
    public function uninstall() {
        $this->initClassLoader();
        $this->wire(new \VersionControl\DatabaseHelper())->dropTables();
        if (is_dir($this->path)) {
            wireRmdir($this->path, true);
        }
    }

    /**
     * Handle saving module config data for the companion modules
     *
     * @param HookEvent $event
     */
    protected function saveConfigData(HookEvent $event) {
        $data = $event->arguments[1];
        $ext_data = [
            'p' => ['ProcessVersionControl', []],
            'c' => ['VersionControlCleanup', []],
        ];
        foreach ($data as $key => $value) {
            $suffix = substr($key, -2);
            if ($suffix == '_p' || $suffix == '_c') {
                $ext_key = substr($key, 0, strlen($key) - 2);
                $ext_data[$suffix[1]][1][$ext_key] = $value;
                unset($data[$key]);
            }
        }
        $event->arguments(1, $data);
        foreach ($ext_data as $ext_key => $ext_module) {
            if (!$this->wire('modules')->isInstalled($ext_module[0])) continue;
            $this->wire('modules')->saveModuleConfigData($ext_module[0], $ext_module[1]);
        }
    }

    /**
     * Regenerate data when enabled templates and/or fields change
     *
     * @param HookEvent $event
     */
    protected function regenerateData(HookEvent $event) {

        // Find out which new templates have been enabled.
        $new_templates = $event->arguments[1]['enabled_templates'];
        if ($event->arguments[1]['enable_all_templates']) {
            $new_templates = [];
            foreach ($this->wire('templates')->getAll() as $key => $template) {
                if ($template->name != "language") $new_templates[] = $key;
            }
        }

        // Find out which templates were already enabled.
        $old_templates = $this->enabled_templates;
        if ($this->enable_all_templates) {
            $old_templates = [];
            foreach ($this->wire('templates')->getAll() as $key => $template) {
                if ($template->name != "language") $old_templates[] = $key;
            }
        }

        // Fetch a list of enabled fields (old and new) plus all fields in case that no fields are
        // enabled (which means that all fields are enabled).
        $new_fields = $event->arguments[1]['enabled_fields'];
        $old_fields = $this->enabled_fields;
        $all_fields = [];
        $all_new_fields = [];
        $all_old_fields = [];
        if (!$new_fields && $old_fields || $new_fields && !$old_fields) {
            // A minor optimization: if both are undefined we never come this far since there have
            // obviously been no changes to enabled fields.
            foreach ($this->templates->find('id=' . implode('|', array_unique(array_merge($old_templates, $new_templates)))) as $template) {
                foreach ($template->fields as $field) {
                    if (in_array($field->type, $this->compatible_fieldtypes)) {
                        if (!in_array($field->id, $all_fields)) {
                            $all_fields[] = $field->id;
                            if (in_array($template->id, $new_templates)) {
                                $all_new_fields[] = $field->id;
                            }
                            if (in_array($template->id, $old_templates)) {
                                $all_old_fields[] = $field->id;
                            }
                        }
                    }
                }
            }
        }

        // Make sure that enabled fields are up to date.
        $this->enabled_fields = $new_fields;

        // Find out which (if any) templates were added and need regenerating.
        $regenerate_templates = array_diff($new_templates, $old_templates);

        // Fetch a list of templates containing at least one newly enabled field.
        $added_fields = array_diff($new_fields ?: $all_new_fields, $old_fields ?: $all_old_fields);
        if ($added_fields) {
            foreach ($new_templates as $template) {
                if (in_array($template, $regenerate_templates)) continue;
                $template = $this->templates->get((int) $template);
                foreach ($added_fields as $field) {
                    if ($template->hasField((int) $field)) {
                        $regenerate_templates[] = $template->id;
                        break;
                    }
                }
            }
        }

        // Populate new data.
        if ($regenerate_templates) {
            $cache_items = 0;
            foreach ($regenerate_templates as $template) {
                $count = 0;
                $template = $this->templates->get((int) $template);
                foreach ($this->pages->find('template=' . $template . ', include=all') as $page) {
                    $this->readPageData($page, null, true);
                    $this->savePageData($page);
                    ++$count;
                    ++$cache_items;
                    if ($cache_items > 100) {
                        // Avoid consuming too much memory by running in batches.
                        $this->pages->uncacheAll();
                        $cache_items = 0;
                    }
                }
                if ($count) {
                    $this->message(sprintf(
                        i18n::getText('Populated data for %d page using template %s', 'Populated data for %d pages using template %s', $count),
                        $count,
                        $template
                    ));
                }
            }
        }

        // Find out which (if any) templates were removed and cleanup data.
        $removed_templates = array_diff($old_templates, $new_templates);
        if (!empty($removed_templates)) {
            $t1 = self::TABLE_REVISIONS;
            $t2 = self::TABLE_DATA;
            foreach ($removed_templates as $template) {
                $template = $this->templates->get((int) $template);
                $page_ids = array_values($this->pages->find("template={$template}, include=all")->getArray());
                $page_count = count($page_ids);
                if (!empty($page_count)) {
                    $stmt = $this->database->prepare("DELETE $t1, $t2 FROM $t1, $t2 WHERE $t1.pages_id IN (" . rtrim(str_repeat('?, ', $page_count), ', ') . ") AND $t2.revisions_id = $t1.id");
                    $stmt->execute($page_ids);
                    $this->cleanupFiles();
                    $this->message(sprintf(
                        i18n::getText('Removed stored data for %d page using template %s', 'Removed stored data for %d pages using template %s', $page_count),
                        $page_count,
                        $template
                    ));
                }
            }
        }

        // Find out which (if any) fields were removed and cleanup data.
        if ($new_fields) {
            // Note: if enabled fields are not defined (all fields are enabled), there's no need to clean up anything.
            $removed_fields = array_diff($old_fields ?: $all_old_fields, $new_fields ?: $all_new_fields);
            if (!empty($removed_fields)) {
                foreach ($removed_fields as $fields_id) {

                    // Validate field ID and make sure that the field exists.
                    if ((int) $fields_id != $fields_id) continue;
                    $field = $this->fields->get($fields_id);
                    if (!$field instanceof Field) continue;

                    // If field doesn't exist, this point should never be reached; data belonging to removed fields is
                    // cleaned up elsewhere.
                    $stmt = $this->database->prepare('DELETE FROM ' . self::TABLE_DATA . ' WHERE fields_id = :fields_id');
                    $stmt->bindValue(':fields_id', $fields_id, \PDO::PARAM_INT);
                    $stmt->execute();
                    $this->cleanupFiles();
                    $this->message(sprintf(
                        i18n::getText('Removed stored data for field %s'),
                        $field->name
                    ));
                }
            }
        }
    }

    /**
     * Check if version control is enabled for specific template
     *
     * @param Template $template
     * @return bool
     */
    protected function isEnabledTemplate(Template $template): bool {
        if ($template->name == 'language') {
            return false;
        }
        if ($this->enable_all_templates || in_array($template->id, $this->enabled_templates)) {
            return true;
        }
        return false;
    }

    /**
     * Custom getter for caching runtime variables
     *
     * Note: we use the files directory of the page associated with ProcessVersionControl as file storage. This method
     * finds and caches the path and URL of this directory, and creates it if it doesn't exist yet.
     *
     * @param string $key
     * @return mixed
     */
    public function __get($key) {
        switch ($key) {
            case "path":
            case "url":
                if (!array_key_exists($key, $this->data)) {
                    $processModuleID = $this->wire('modules')->getModuleID('ProcessVersionControl');
                    if ($processModuleID) {
                        $processPage = $this->wire('pages')->get('template=admin, process=' . $processModuleID . ', name=version-control');
                        if ($processPage->id) {
                            $pagefilesManager = $this->wire(new PagefilesManager($processPage));
                            $this->data['path'] = $pagefilesManager->path();
                            $this->data['url'] = $pagefilesManager->url();
                            if (!is_dir($this->data['path'])) {
                                wireMkdir($this->data['path']);
                            }
                        }
                    }
                }
                return $this->data[$key] ?? null;
                break;
            case "use_fileinfo":
                if (!array_key_exists($key, $this->data)) {
                    $this->data[$key] = extension_loaded('fileinfo') && function_exists('finfo_open');
                }
                return $this->data[$key];
                break;
            case "use_mime_content_type":
                if (!array_key_exists($key, $this->data)) {
                    $this->data[$key] = function_exists('mime_content_type');
                }
                return $this->data[$key];
                break;
        }
        return parent::get($key);
    }

    /**
     * Method overloading support
     *
     * This method provides access to companion module features. For an example if a cleanup method is requested, we
     * check if it exists in VersionControlCleanup and then pass the request there.
     *
     * @param string $method Method name.
     * @param array $arguments Array of arguments.
     * @return mixed
     */
    public function __call($method, $arguments) {
        if (strpos($method, "cleanup") === 0) {
            $cleanup = $this->wire('modules')->get('VersionControlCleanup');
            if ($cleanup) {
                return call_user_func_array([
                    $cleanup,
                    $method
                ], $arguments);
            }
        }
        return parent::__call($method, $arguments);
    }

}
